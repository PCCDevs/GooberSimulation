<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goober Ecosystem: Silly Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            max-width: 1000px;
            width: 95%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
        }
        #gameCanvas {
            border: 2px solid #3b82f6;
            background-color: #e0f2fe;
            border-radius: 0.75rem;
            width: 100%;
            max-width: 600px; 
            height: auto;
            touch-action: none;
        }
        .info-card {
            background-color: #eff6ff;
            border-left: 4px solid #3b82f6;
            padding: 0.75rem;
            border-radius: 0.5rem;
        }
        /* Button Styles */
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn:active {
            transform: scale(0.98);
        }
        .btn-primary {
            background-color: #3b82f6;
            color: white;
        }
        .btn-primary:hover {
            background-color: #2563eb;
        }
        .btn-danger {
            background-color: #ef4444;
            color: white;
        }
        .btn-danger:hover {
            background-color: #dc2626;
        }
        .btn-pause {
            background-color: #f59e0b; /* Amber for Pause */
            color: white;
        }
        .btn-pause:hover {
            background-color: #d97706;
        }
        /* Custom highlight for selected goober */
        .selected-highlight {
            border: 3px solid #f97316; /* Orange ring */
        }
    </style>
</head>
<body>

<div class="container">
    <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">Goober Ecosystem: Silly Edition</h1>

    <!-- Existing Aggregate Info Panel -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 w-full">
        <div class="info-card">
            <h3 class="font-semibold text-blue-800">Status</h3>
            <p id="status-display" class="text-sm text-gray-700">Initial setup...</p>
        </div>
        <div class="info-card">
            <h3 class="font-semibold text-blue-800">Controls</h3>
            <p class="text-xs text-gray-700">LClick/Tap: Add Food (Green Dot)<br>RClick/LPress: Add Water (Blue Dot)</p>
        </div>
        <div class="info-card">
            <h3 class="font-semibold text-blue-800">Population</h3>
            <p id="population-display" class="text-sm text-gray-700">Goobers: 0 | Resources: 0 | Killbers: 0</p>
        </div>
    </div>

    <canvas id="gameCanvas" width="600" height="600" class="max-w-full"></canvas>

    <div class="flex flex-wrap justify-center gap-4 mt-4">
        <button id="add-goober-btn" class="btn btn-primary">Add Goober</button>
        <button id="add-killber-btn" class="btn btn-danger">Add Killber</button>
        <button id="pause-btn" class="btn btn-pause">Pause</button>
        <button id="reset-btn" class="btn btn-primary bg-gray-500 hover:bg-gray-600">Reset Simulation</button>
    </div>

    <!-- Selected Creature Details Panel -->
    <div id="selected-goober-panel" class="w-full mt-4 p-4 bg-yellow-50 border border-yellow-300 rounded-xl shadow-lg">
        <h3 class="text-xl font-bold text-yellow-800 mb-2 border-b border-yellow-300 pb-1">Selected Creature Stats</h3>
        <div id="selected-goober-details" class="text-sm text-gray-700">
            <p class="text-center text-gray-500 py-4">Click a Goober or Killber on the map to see its detailed status.</p>
        </div>
    </div>

    <!-- Detailed Goober Info Panel (Top 5) -->
    <div id="goober-details-panel" class="w-full mt-4 p-4 bg-gray-100 border border-gray-300 rounded-xl shadow-lg">
        <h3 class="text-xl font-bold text-gray-700 mb-3 border-b pb-1">Goober Status (Top 5 Neediest)</h3>
        <div id="goober-list" class="space-y-2">
            <!-- Goober details will be inserted here by JavaScript -->
        </div>
    </div>
</div>

<script>
    // --- Configuration ---
    const CANVAS_SIZE = 600; 
    const GRID_SIZE = 15; 
    const TILE_SIZE = CANVAS_SIZE / GRID_SIZE;

    const GOOBER_SIZE = 10;
    const KILLBER_SIZE = 15; 
    const KILLBER_SPEED = 2.5; 
    
    const RESOURCE_SIZE = 5;
    const MAX_HUNGER_LEVEL = 1;
    const MAX_THIRST_LEVEL = 1;
    
    // ADJUSTED DECAY RATES: 
    const GOOBER_DECAY_RATE = 0.0002; // ~83 second lifespan
    // Killbers now have a reasonable lifespan and feeding rate
    const KILLBER_DECAY_RATE = 0.0006; // ~27.7 second lifespan (4.5x Goober rate)

    const RESOURCE_SPAWN_RATE = 0.05; 
    const MAX_POPULATION = 50;

    const BIOMES = {
        GRASS: { color: '#86efac', moveCost: 1, resourceType: 'food', resourceRate: 0.5, name: 'Grassland' },
        FOREST: { color: '#16a34a', moveCost: 3, resourceType: 'food', resourceRate: 0.1, name: 'Forest' },
        DESERT: { color: '#fcd34d', moveCost: 2, resourceType: 'water', resourceRate: 0.1, name: 'Desert' },
        POND: { color: '#60a5fa', moveCost: 5, resourceType: 'water', resourceRate: 0.8, name: 'Pond' } 
    };

    // --- State & UI Elements ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = CANVAS_SIZE;
    canvas.height = CANVAS_SIZE;

    const statusDisplay = document.getElementById('status-display');
    const populationDisplay = document.getElementById('population-display');
    const gooberListPanel = document.getElementById('goober-list'); 
    const selectedGooberDetails = document.getElementById('selected-goober-details'); 
    const pauseButton = document.getElementById('pause-btn');

    let gooberList = [];
    let killberList = []; 
    let resourceList = [];
    let mapGrid = [];
    let animationFrameId;
    let isRunning = true;
    let selectedGoober = null; 
    
    let cycleCounter = 0; // Global cycle counter

    // --- Utility Functions ---
    const randomCoord = (max) => Math.random() * max;
    const distance = (x1, y1, x2, y2) => Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    
    function getTileIndex(x, y) {
        const gridX = Math.floor(x / TILE_SIZE);
        const gridY = Math.floor(y / TILE_SIZE);

        if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
            // FIX: Access the biome using the integer gridY and gridX indices
            return { x: gridX, y: gridY, biome: mapGrid[gridY][gridX] };
        }
        // Return default biome if out of bounds
        return { x: -1, y: -1, biome: BIOMES.GRASS }; 
    }
    
    const getTileCenter = (gridX, gridY) => ({
        x: gridX * TILE_SIZE + TILE_SIZE / 2,
        y: gridY * TILE_SIZE + TILE_SIZE / 2
    });
    
    /**
     * Draws the silly goober face/sprite onto the canvas.
     * @param {number} x The x-coordinate center.
     * @param {number} y The y-coordinate center.
     * @param {number} size The radius of the goober body.
     * @param {string} color The main body color.
     */
    function drawSillyGoober(x, y, size, color) {
        // Body (a slightly squashed, irregular blob for silliness)
        ctx.beginPath();
        ctx.ellipse(x, y, size, size * 1.1, 0, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = '#22c55e';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.closePath();

        // Eyes (white circles)
        const eyeRadius = size * 0.25;
        const eyeOffset = size * 0.4;
        
        ctx.fillStyle = 'white';
        // Left Eye
        ctx.beginPath();
        ctx.arc(x - eyeOffset, y - eyeOffset * 0.5, eyeRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        // Right Eye
        ctx.beginPath();
        ctx.arc(x + eyeOffset, y - eyeOffset * 0.5, eyeRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        
        // Pupils (black dots) - slightly off center for a goofy look
        const pupilRadius = eyeRadius * 0.5;
        ctx.fillStyle = 'black';
        ctx.beginPath();
        // Left Pupil (looking slightly inward)
        ctx.arc(x - eyeOffset + pupilRadius * 0.5, y - eyeOffset * 0.5 + pupilRadius * 0.2, pupilRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        // Right Pupil (looking slightly inward)
        ctx.beginPath();
        ctx.arc(x + eyeOffset - pupilRadius * 0.5, y - eyeOffset * 0.5 + pupilRadius * 0.2, pupilRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();

        // Mouth (simple curve)
        ctx.beginPath();
        ctx.arc(x, y + size * 0.3, size * 0.4, 0, Math.PI);
        ctx.strokeStyle = '#6366f1'; // Indigo for mouth
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.closePath();
    }


    // --- Selection Logic ---

    function getClickedGoober(x, y) {
        // Check Killbers first (they are bigger and drawn later)
        for (let i = killberList.length - 1; i >= 0; i--) {
            const killber = killberList[i];
            if (distance(x, y, killber.x, killber.y) < killber.size) {
                return killber;
            }
        }

        // Then check Goobers
        for (let i = gooberList.length - 1; i >= 0; i--) {
            const goober = gooberList[i];
            // Since Goobers are slightly elliptical, use a larger radius for click detection
            if (distance(x, y, goober.x, goober.y) < goober.size * 1.2) {
                return goober;
            }
        }
        return null;
    }

    // --- Map Generation ---
    function generateMap() {
        mapGrid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(BIOMES.GRASS));

        const coreBiomeTypes = [BIOMES.FOREST, BIOMES.DESERT, BIOMES.POND];
        const numFeatures = 8;

        for (let i = 0; i < numFeatures; i++) {
            const biome = coreBiomeTypes[Math.floor(Math.random() * coreBiomeTypes.length)];
            const size = Math.floor(Math.random() * 4) + 2; // Size 2 to 5
            const startX = Math.floor(Math.random() * (GRID_SIZE - size));
            const startY = Math.floor(Math.random() * (GRID_SIZE - size));

            // Create a square patch
            for (let x = startX; x < startX + size; x++) {
                for (let y = startY; y < startY + size; y++) {
                    if (y < GRID_SIZE && x < GRID_SIZE) {
                        mapGrid[y][x] = biome;
                    }
                }
            }
        }
    }

    function drawMap() {
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                ctx.fillStyle = mapGrid[y][x].color;
                ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    function spawnResources() {
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const biome = mapGrid[y][x];

                if (Math.random() < biome.resourceRate * RESOURCE_SPAWN_RATE) {
                    const center = getTileCenter(x, y);
                    const resourceX = center.x + (Math.random() * TILE_SIZE * 0.5) - TILE_SIZE * 0.25;
                    const resourceY = center.y + (Math.random() * TILE_SIZE * 0.5) - TILE_SIZE * 0.25;
                    
                    const type = (biome.resourceType === 'food' && Math.random() < 0.8) ? 'food' : 
                                 (biome.resourceType === 'water' && Math.random() < 0.8) ? 'water' :
                                 (Math.random() < 0.5 ? 'food' : 'water');

                    resourceList.push(new Resource(resourceX, resourceY, type));
                }
            }
        }
    }

    // --- Base Creature Class (For shared logic) ---
    class Creature {
        constructor(x, y, size, speed, type) {
            this.x = x || randomCoord(canvas.width);
            this.y = y || randomCoord(canvas.height);
            this.size = size;
            this.speed = speed;
            this.type = type; 

            this.hunger = 0.5; 
            this.thirst = 0.5; 
            this.target = null; 
            this.lastAction = 'Spawning';
            this.id = crypto.randomUUID(); 
        }

        drawHealthIndicators() {
            const barWidth = 12;
            const barHeight = 2;
            const offsetY = this.y - this.size * 2.5; // Adjusted offset due to new sprites

            // Thirst Indicator (Blue)
            ctx.fillStyle = `rgba(59, 130, 246, 0.5)`; 
            ctx.fillRect(this.x - barWidth / 2, offsetY, barWidth, barHeight);
            ctx.fillStyle = `rgb(59, 130, 246)`; 
            ctx.fillRect(this.x - barWidth / 2, offsetY, barWidth * this.thirst, barHeight);

            // Hunger Indicator (Green/Red)
            ctx.fillStyle = this.type === 'goober' ? `rgba(16, 185, 129, 0.5)` : `rgba(255, 99, 71, 0.5)`;
            ctx.fillRect(this.x - barWidth / 2, offsetY + 3, barWidth, barHeight);
            ctx.fillStyle = this.type === 'goober' ? `rgb(16, 185, 129)` : `rgb(255, 99, 71)`; 
            ctx.fillRect(this.x - barWidth / 2, offsetY + 3, barWidth * this.hunger, barHeight);
            
            // Highlight if selected
            if (selectedGoober === this) {
                 ctx.beginPath();
                 ctx.arc(this.x, this.y, this.size * 1.3 + 3, 0, Math.PI * 2);
                 ctx.strokeStyle = '#f97316'; 
                 ctx.lineWidth = 2;
                 ctx.stroke();
                 ctx.closePath();
            }
        }

        isDead() {
            return this.hunger <= 0 || this.thirst <= 0;
        }

        applyMovement() {
            const { biome } = getTileIndex(this.x, this.y);
            let effectiveSpeed = this.speed / biome.moveCost; 
            
            if (this.target) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = distance(0, 0, dx, dy);

                // Use a dynamic arrival threshold based on speed to reduce jitter
                const arrivalThreshold = Math.max(this.size * 0.7, effectiveSpeed * 1.5); 

                if (dist > arrivalThreshold) { 
                    this.x += (dx / dist) * effectiveSpeed;
                    this.y += (dy / dist) * effectiveSpeed;
                } else {
                    return true; // Arrived
                }
            } else {
                // Random move if no target
                this.x += (Math.random() - 0.5) * effectiveSpeed * 2;
                this.y += (Math.random() - 0.5) * effectiveSpeed * 2;
            }
            
            // Boundary checks
            this.x = Math.max(this.size, Math.min(this.x, canvas.width - this.size));
            this.y = Math.max(this.size, Math.min(this.y, canvas.height - this.size));
            return false;
        }

        findResourceTarget(type) {
            let bestTarget = { dist: Infinity, item: null };
            
            resourceList.forEach(resource => {
                if (resource.type === type) {
                    const dist = distance(this.x, this.y, resource.x, resource.y);
                    if (dist < bestTarget.dist) {
                        bestTarget = { dist, item: resource };
                    }
                }
            });

            if (bestTarget.item) {
                this.target = { x: bestTarget.item.x, y: bestTarget.item.y, type: type, resource: bestTarget.item };
                return true;
            }
            return false;
        }
    }

    // --- Goober Class (Prey) ---
    class Goober extends Creature {
        constructor(x, y) {
            super(x, y, GOOBER_SIZE, 1.5, 'goober');
            this.reproductionCooldown = 0;
        }

        draw() {
            // Calculate color based on health (Red for low, Green for good)
            const overallHealth = (this.hunger + this.thirst) / 2;
            const r = Math.min(255, Math.floor((1 - overallHealth) * 255 * 1.5));
            const g = Math.min(255, Math.floor(overallHealth * 255));
            const color = `rgb(${r}, ${g}, 50)`;

            drawSillyGoober(this.x, this.y, this.size, color);

            this.drawHealthIndicators();
        }

        update() {
            if (this.isDead()) {
                this.lastAction = 'Deceased';
                return;
            }

            // 1. Aging (Decrease Health) - Uses the slower GOOBER_DECAY_RATE
            this.hunger = Math.max(0, this.hunger - GOOBER_DECAY_RATE);
            this.thirst = Math.max(0, this.thirst - GOOBER_DECAY_RATE);
            
            // 2. Escape Logic (If Killber is nearby)
            const nearestKillber = this.findNearestKillber();
            if (nearestKillber && distance(this.x, this.y, nearestKillber.x, nearestKillber.y) < 150) {
                this.lastAction = 'Fleeing';
                this.flee(nearestKillber);
                this.applyMovement();
                this.reproductionCooldown = Math.max(this.reproductionCooldown, 100); 
                return;
            }

            // 3. AI Decision (Find Target - Food/Water)
            if (this.hunger < this.thirst && this.hunger < 0.8) {
                this.findTarget('food');
                this.lastAction = 'Seeking Food';
            } else if (this.thirst < 0.8) {
                this.findTarget('water');
                this.lastAction = 'Seeking Water';
            } else {
                if (this.target) this.target = null;
                this.lastAction = 'Wandering';
            }
            
            // 4. Move
            this.applyMovement();

            // 5. Cooldown
            if (this.reproductionCooldown > 0) {
                this.reproductionCooldown--;
            }
        }
        
        findNearestKillber() {
            if (killberList.length === 0) return null;
            let nearest = null;
            let minDist = Infinity;
            
            killberList.forEach(killber => {
                const dist = distance(this.x, this.y, killber.x, killber.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = killber;
                }
            });
            return nearest;
        }

        flee(predator) {
            const dx = this.x - predator.x;
            const dy = this.y - predator.y;
            // Calculate a point far away in the opposite direction
            const fleeDistance = 200; 
            const dist = distance(0, 0, dx, dy);
            
            this.target = { 
                x: this.x + (dx / dist) * fleeDistance, 
                y: this.y + (dy / dist) * fleeDistance,
                type: 'escape' 
            };
        }

        findTarget(type) {
            if (this.findResourceTarget(type)) return;

            // Fallback: Find nearest high-rate spawning tile
            let bestTile = { dist: Infinity, x: null, y: null };
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const biome = mapGrid[y][x];
                    if (biome.resourceType === type && biome.resourceRate > 0.4) {
                        const center = getTileCenter(x, y);
                        const dist = distance(this.x, this.y, center.x, center.y);
                        if (dist < bestTile.dist) {
                            bestTile = { dist, x: center.x, y: center.y };
                        }
                    }
                }
            }

            if (bestTile.dist !== Infinity) {
                this.target = { x: bestTile.x, y: bestTile.y, type: type };
            } else {
                this.target = null; 
            }
        }

        eat() {
            this.hunger = Math.min(MAX_HUNGER_LEVEL, this.hunger + 0.35);
        }

        drink() {
            this.thirst = Math.min(MAX_THIRST_LEVEL, this.thirst + 0.35);
        }

        reproduce() {
            const REPRODUCTION_THRESHOLD = 0.85;
            const REPRODUCTION_COOLDOWN = 600;

            if (gooberList.length >= MAX_POPULATION) return null;

            const isSatiated = this.hunger > REPRODUCTION_THRESHOLD && this.thirst > REPRODUCTION_THRESHOLD;
            const isReady = this.reproductionCooldown === 0;

            if (isReady && isSatiated) {
                this.reproductionCooldown = REPRODUCTION_COOLDOWN;
                this.hunger -= 0.1; 
                this.thirst -= 0.1;

                const babyX = this.x + (Math.random() * 20 - 10);
                const babyY = this.y + (Math.random() * 20 - 10);

                const newGoober = new Goober(babyX, babyY);
                newGoober.hunger = 0.4;
                newGoober.thirst = 0.4;
                return newGoober;
            }
            return null;
        }
    }
    
    // --- Killber Class (Predator) ---
    class Killber extends Creature {
        constructor(x, y) {
            super(x, y, KILLBER_SIZE, KILLBER_SPEED, 'killber');
        }

        draw() {
            const overallHealth = (this.hunger + this.thirst) / 2;
            const color = overallHealth > 0.2 ? '#b91c1c' : '#450a0a'; 

            // Body (Triangle/Sharp shape)
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.size);
            ctx.lineTo(this.x + this.size, this.y + this.size / 2);
            ctx.lineTo(this.x - this.size, this.y + this.size / 2);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.stroke();

            this.drawHealthIndicators();
        }

        update() {
            if (this.isDead()) {
                this.lastAction = 'Deceased';
                return;
            }

            // 1. Aging (Decrease Health) - Killber hunger decays at the full rate (0.0006), 
            // but thirst decays slightly slower to make hunting for food the main focus.
            this.hunger = Math.max(0, this.hunger - KILLBER_DECAY_RATE); 
            this.thirst = Math.max(0, this.thirst - KILLBER_DECAY_RATE * 0.5);

            // 2. AI Decision
            if (this.hunger < 0.7 && gooberList.length > 0) {
                // Priority 1: Hunt Goobers if hungry
                this.lastAction = 'Hunting Goobers';
                this.findPreyTarget();
            } else if (this.thirst < 0.3) {
                // Priority 2: Drink if very thirsty
                this.lastAction = 'Seeking Water';
                this.findTarget('water');
            } else if (this.hunger < 0.3) {
                 // Priority 3: Scavenge if very hungry but no Goobers are nearby or available
                 this.lastAction = 'Seeking Scavenge Food';
                 this.findTarget('food');
            } else {
                if (this.target) this.target = null;
                this.lastAction = 'Patrolling';
            }

            // 3. Move
            this.applyMovement();
        }

        findPreyTarget() {
            let bestTarget = { dist: Infinity, prey: null };

            // Find the closest Goober to hunt
            gooberList.forEach(goober => {
                const dist = distance(this.x, this.y, goober.x, goober.y);
                if (dist < bestTarget.dist) {
                    minDist = dist;
                    bestTarget = { dist, prey: goober };
                }
            });

            if (bestTarget.prey) {
                // If the target is the same as the previous frame, update its coordinates (chase)
                if (this.target && this.target.prey === bestTarget.prey) {
                    this.target.x = bestTarget.prey.x;
                    this.target.y = bestTarget.prey.y;
                } else {
                    // Lock onto new prey
                    this.target = { 
                        x: bestTarget.prey.x, 
                        y: bestTarget.prey.y, 
                        type: 'prey', 
                        prey: bestTarget.prey 
                    };
                }
            } else {
                this.target = null;
            }
        }
        
        findTarget(type) {
             if (this.findResourceTarget(type)) return;

            // Fallback: Find nearest high-rate spawning tile
            let bestTile = { dist: Infinity, x: null, y: null };
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const biome = mapGrid[y][x];
                    if (biome.resourceType === type && biome.resourceRate > 0.4) {
                        const center = getTileCenter(x, y);
                        const dist = distance(this.x, this.y, center.x, center.y);
                        if (dist < bestTile.dist) {
                            bestTile = { dist, x: center.x, y: center.y };
                        }
                    }
                }
            }

            if (bestTile.dist !== Infinity) {
                this.target = { x: bestTile.x, y: bestTile.y, type: type };
            } else {
                this.target = null; 
            }
        }
        
        consumeGoober() {
             this.hunger = Math.min(MAX_HUNGER_LEVEL, this.hunger + 0.6); 
        }
        
        drink() {
            this.thirst = Math.min(MAX_THIRST_LEVEL, this.thirst + 0.35);
        }
        
        scavenge() {
            this.hunger = Math.min(MAX_HUNGER_LEVEL, this.hunger + 0.35);
        }
    }


    class Resource {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.size = RESOURCE_SIZE;
            this.type = type; // 'food' or 'water'
            this.color = type === 'food' ? '#10b981' : '#3b82f6';
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.closePath();
        }
    }

    // --- Simulation Core Logic ---

    function initializeSimulation() {
        gooberList = [];
        killberList = [];
        resourceList = [];
        selectedGoober = null; 
        cycleCounter = 0;
        generateMap();

        for (let i = 0; i < 10; i++) {
            gooberList.push(new Goober());
        }
        
        spawnResources(); 

        // Ensure the button state and loop state match initialization
        if (!isRunning) {
            isRunning = true;
            pauseButton.textContent = "Pause";
            gameLoop();
        }
    }

    function checkCollisions() {
        const consumedResourceIndices = new Set();
        const killedGooberIndices = new Set();
        const newGoobers = [];

        // 1. Killber vs Goober/Resource Collisions
        killberList.forEach(killber => {
            if (killber.isDead()) return;

            // Check Goober Hunt
            if (killber.target && killber.target.type === 'prey') {
                const targetGoober = killber.target.prey;
                const gooberIndex = gooberList.indexOf(targetGoober);
                
                // Consumption range is Killber size + Goober size
                if (gooberIndex !== -1 && distance(killber.x, killber.y, targetGoober.x, targetGoober.y) < killber.size + targetGoober.size) {
                    killedGooberIndices.add(gooberIndex);
                    killber.consumeGoober();
                    killber.target = null;
                }
            }

            // Check Resource Scavenge/Drink
            for (let i = 0; i < resourceList.length; i++) {
                if (consumedResourceIndices.has(i)) continue;

                const resource = resourceList[i];
                if (distance(killber.x, killber.y, resource.x, resource.y) < killber.size + resource.size) {
                    
                    if (resource.type === 'food' && killber.hunger < MAX_HUNGER_LEVEL) {
                        killber.scavenge();
                        consumedResourceIndices.add(i);
                        break; 
                    } else if (resource.type === 'water' && killber.thirst < MAX_THIRST_LEVEL) {
                        killber.drink();
                        consumedResourceIndices.add(i);
                        break;
                    }
                }
            }
        });


        // 2. Goober vs Resource Collisions (and Reproduction)
        gooberList.forEach((goober, gooberIndex) => {
            if (goober.isDead() || killedGooberIndices.has(gooberIndex)) return;

            // Consumption
            for (let i = 0; i < resourceList.length; i++) {
                if (consumedResourceIndices.has(i)) continue;

                const resource = resourceList[i];
                if (distance(goober.x, goober.y, resource.x, resource.y) < goober.size + resource.size) {
                    
                    if (resource.type === 'food' && goober.hunger < MAX_HUNGER_LEVEL) {
                        goober.eat();
                        consumedResourceIndices.add(i);
                        break; 
                    } else if (resource.type === 'water' && goober.thirst < MAX_THIRST_LEVEL) {
                        goober.drink();
                        consumedResourceIndices.add(i);
                        break;
                    }
                }
            }

            // Reproduction check
            const baby = goober.reproduce();
            if (baby) {
                newGoobers.push(baby);
            }
        });
        
        // Update Lists
        gooberList.push(...newGoobers);
        resourceList = resourceList.filter((_, index) => !consumedResourceIndices.has(index));
        
        // Filter out Goobers that were eaten or died of starvation/thirst
        const finalGooberList = gooberList.filter((_, index) => !killedGooberIndices.has(index));
        gooberList = finalGooberList.filter(goober => !goober.isDead());
        killberList = killberList.filter(killber => !killber.isDead());
        
        // Check if selected creature died
        if (selectedGoober && (selectedGoober.isDead() || (selectedGoober.type === 'goober' && gooberList.indexOf(selectedGoober) === -1) || (selectedGoober.type === 'killber' && killberList.indexOf(selectedGoober) === -1))) {
             selectedGoober = null;
        }
    }

    function update() {
        cycleCounter++;
        gooberList.forEach(goober => goober.update());
        killberList.forEach(killber => killber.update());
        checkCollisions();

        if (cycleCounter % 300 === 0) { 
            spawnResources();
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        drawMap();

        // Draw Resources
        resourceList.forEach(resource => resource.draw());

        // Draw Goobers (Prey)
        gooberList.forEach(goober => goober.draw());

        // Draw Killbers (Predators) - Draw last so they are on top
        killberList.forEach(killber => killber.draw());
    }

    function gameLoop() {
        if (!isRunning) {
            animationFrameId = null;
            return;
        }

        update();
        draw();
        updateUI();

        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function togglePause() {
        isRunning = !isRunning;
        if (isRunning) {
            pauseButton.textContent = "Pause";
            gameLoop();
            statusDisplay.textContent = `Ecosystem resumed (Cycle: ${cycleCounter}).`;
        } else {
            pauseButton.textContent = "Resume";
            statusDisplay.textContent = `Ecosystem paused (Cycle: ${cycleCounter}).`;
        }
    }

    function updateUI() {
        const totalResources = resourceList.length;
        const gooberCount = gooberList.length;
        const killberCount = killberList.length;

        populationDisplay.innerHTML = `Goobers: <span class="font-bold text-green-700">${gooberCount}</span> | Resources: <span class="font-bold text-blue-700">${totalResources}</span> | Killbers: <span class="font-bold text-red-700">${killberCount}</span>`;

        if (gooberCount === 0 && killberCount === 0) {
            statusDisplay.textContent = "EXTINCTION! All creatures perished.";
            statusDisplay.classList.add('text-red-600', 'font-bold');
            isRunning = false;
        } else if (gooberCount === 0 && killberCount > 0) {
            statusDisplay.textContent = "Goobers are extinct. Killbers are starving...";
            statusDisplay.classList.add('text-red-600', 'font-bold');
        } else if (gooberCount >= MAX_POPULATION) {
            statusDisplay.textContent = `MAX GOOBER POPULATION (${MAX_POPULATION}) reached! Population pressure is high.`;
            statusDisplay.classList.remove('text-red-600', 'font-bold');
        } else if (isRunning) {
            statusDisplay.textContent = `Ecosystem stable (Cycle: ${cycleCounter}).`;
            statusDisplay.classList.remove('text-red-600', 'font-bold');
        }

        // --- Selected Creature Panel Update ---
        if (selectedGoober) {
            const creature = selectedGoober;
            const { biome } = getTileIndex(creature.x, creature.y);
            
            let creatureIndex;
            if (creature.type === 'goober') {
                creatureIndex = gooberList.indexOf(creature) + 1;
            } else {
                creatureIndex = killberList.indexOf(creature) + 1;
            }
            
            const statusColor = creature.isDead() ? 'text-red-600' : 'text-green-600';

            selectedGooberDetails.innerHTML = `
                <h4 class="text-lg font-bold ${creature.type === 'killber' ? 'text-red-700' : 'text-green-700'}">${creature.type.toUpperCase()} #${creatureIndex}</h4>
                <div class="grid grid-cols-2 gap-2 text-sm">
                    <p><strong>ID/Index:</strong> <span class="font-mono text-xs">${creature.id.substring(0, 8)}...</span> / #${creatureIndex}</p>
                    <p><strong>Status:</strong> <span class="font-bold ${statusColor}">${creature.isDead() ? 'DECEASED' : 'ALIVE'}</span></p>
                    <p><strong>Hunger:</strong> ${ (creature.hunger * 100).toFixed(1) }%</p>
                    <p><strong>Thirst:</strong> ${ (creature.thirst * 100).toFixed(1) }%</p>
                    ${creature.type === 'goober' ? `<p><strong>Reproduction CD:</strong> ${creature.reproductionCooldown}</p>` : '<p></p>'}
                    <p class="col-span-2"><strong>Location:</strong> ${biome.name} (Move Cost: ${biome.moveCost})</p>
                    <p class="col-span-2"><strong>Current Action:</strong> <span class="font-mono text-gray-800">${creature.lastAction}</span></p>
                </div>
            `;
        } else {
            selectedGooberDetails.innerHTML = '<p class="text-center text-gray-500 py-4">Click a Goober or Killber on the map to see its detailed status.</p>';
        }


        // --- Neediest Goober Panel Update ---
        let detailsHtml = '';
        const topGoobers = gooberList
            .sort((a, b) => (a.hunger + a.thirst) - (b.hunger + b.thirst))
            .slice(0, 5); 

        if (topGoobers.length > 0) {
            detailsHtml = topGoobers.map((goober, index) => {
                const healthScore = (goober.hunger + goober.thirst) / 2;
                const hungerPercent = (goober.hunger * 100).toFixed(0);
                const thirstPercent = (goober.thirst * 100).toFixed(0);
                const statusColor = goober.isDead() ? 'bg-red-500' : 
                                    healthScore < 0.3 ? 'bg-red-500' : 
                                    healthScore < 0.5 ? 'bg-yellow-500' : 
                                    'bg-green-500';

                return `
                    <div class="p-3 border rounded-lg flex flex-col sm:flex-row justify-between items-start sm:items-center bg-white shadow-sm">
                        <div class="flex items-center space-x-2 w-full sm:w-auto">
                            <span class="w-2 h-2 ${statusColor} rounded-full" title="Overall Health Indicator"></span>
                            <span class="font-medium text-gray-800">Goober #${gooberList.indexOf(goober) + 1}</span>
                        </div>
                        <div class="text-xs text-gray-600 space-x-4 flex flex-wrap mt-2 sm:mt-0 sm:justify-end">
                            <span title="Hunger Level">Food: <span class="font-bold text-green-700">${hungerPercent}%</span></span>
                            <span title="Thirst Level">Water: <span class="font-bold text-blue-700">${thirstPercent}%</span></span>
                            <span class="font-mono text-gray-700 truncate max-w-[150px]" title="Current Action">Action: ${goober.lastAction}</span>
                        </div>
                    </div>
                `;
            }).join('');
        } else {
            detailsHtml = '<p class="text-center text-gray-500">No active Goobers.</p>';
        }

        gooberListPanel.innerHTML = detailsHtml;
    }

    // --- Event Handlers ---

    function handlePointerDown(e) {
        // Prevent interaction if paused, unless it's a creature selection
        if (!isRunning) {
             const rect = canvas.getBoundingClientRect();
             const x = (e.clientX - rect.left) * (canvas.width / rect.width);
             const y = (e.clientY - rect.top) * (canvas.height / rect.height);
             const clickedCreature = getClickedGoober(x, y);

             if (clickedCreature) {
                selectedGoober = clickedCreature;
                updateUI(); 
                return;
             }
             return;
        }
        
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY, button;
        let eventType = e.type || (e.button === 0 ? 'click' : e.button === 2 ? 'contextmenu' : 'unknown');

        if (eventType === 'touchstart' || eventType === 'contextmenu_simulated') {
            clientX = e.clientX;
            clientY = e.clientY;
            button = e.button;
        } else if (e.changedTouches && e.changedTouches.length > 0) {
            clientX = e.changedTouches[0].clientX;
            clientY = e.changedTouches[0].clientY;
            button = 0; 
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
            button = e.button;
        }

        const x = (clientX - rect.left) * (canvas.width / rect.width);
        const y = (clientY - rect.top) * (canvas.height / rect.height);
        
        if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) return;

        // 1. Check for Creature Click (Selection)
        const clickedCreature = getClickedGoober(x, y);

        if (clickedCreature && (button === 0 || eventType === 'touchstart' || eventType === 'click')) {
            selectedGoober = clickedCreature;
            updateUI(); 
            return;
        } else {
             selectedGoober = null; // Deselect if empty space clicked
             updateUI();
        }

        // 2. Resource Spawn 
        if (button === 0 || eventType === 'touchstart' || eventType === 'click') { // Left click/Tap -> Food
            resourceList.push(new Resource(x, y, 'food'));
        } else if (button === 2 || eventType === 'contextmenu' || eventType === 'contextmenu_simulated') { // Right click/Long press -> Water
            resourceList.push(new Resource(x, y, 'water'));
        }
    }

    document.getElementById('add-goober-btn').addEventListener('click', () => {
        if (gooberList.length + killberList.length < MAX_POPULATION) {
            gooberList.push(new Goober());
        }
    });
    
    document.getElementById('add-killber-btn').addEventListener('click', () => {
        if (gooberList.length + killberList.length < MAX_POPULATION) {
            killberList.push(new Killber());
        }
    });
    
    pauseButton.addEventListener('click', togglePause);

    document.getElementById('reset-btn').addEventListener('click', () => {
        initializeSimulation();
        updateUI();
    });

    // Mouse click events
    canvas.addEventListener('click', handlePointerDown);
    canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault(); 
        handlePointerDown({ clientX: e.clientX, clientY: e.clientY, button: 2, type: 'contextmenu_simulated' });
    });

    // Touch events for mobile
    let touchStartTime = 0;
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchStartTime = Date.now();
    });
    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        const duration = Date.now() - touchStartTime;
        const touch = e.changedTouches[0];

        if (duration > 500) {
            handlePointerDown({ clientX: touch.clientX, clientY: touch.clientY, button: 2, type: 'contextmenu_simulated' });
        } else {
            handlePointerDown(e);
        }
    });

    // --- Initial Setup ---
    window.onload = initializeSimulation;

</script>
</body>
</html>
